<title>Intro to Web Development</title>
<slide>	

</slide>
<comments></comments>


<title>What is Web Development</title>
<slide>	
	<p>Web development is anything to do with the web.</p>
	<ul>
		<li>Basic pages</li>
		<li>Simple forms</li>
		<li>Entire applications</li>
		<li>Angry Birds</li>
	</ul>
</slide>
<comments></comments>

<title>What are Servers?</title>
<slide>	
	<p>Servers hold content remotely and respond to requests</p>
	<img src="servers.png">
</slide>
<comments></comments>


<title>What is a Client?</title>
<slide>	
	<p>Clients request content from servers.</p>
	<p>Types of client:</p>
	<ul>
		<li>Browsers<img src="browsers.png"></li>
		<li>Robots</li>
		<li>Other Servers</li>
		<li>Angry Birds</li>
	</ul>
</slide>
<comments></comments>


<title>How does the information get there?</title>
<slide>	
	<ul>
		<li>HTTP/HTTPS</li>
		<li>FTP/SFTP</li>
		<li>Telnet</li>
	</ul>
</slide>
<comments>explain http and what a protocol is. SYN/SYNACK/ACK</comments>

<title>Server-side Scripting</title>
<slide>	
	<p>Programming that happens on the server!<p>
		<ul>
			<li>Ruby</li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
		</ul>

</slide>
<comments>list languages, describe them</comments>


<title>Client-side Scripting</title>
<slide>	

</slide>
<comments>explain javascript on the client</comments>

<title>Frameworks are Not Languages</title>
<slide>	
	<p>You will often hear of a framework alongside a language. They aren't languages, just libraries that are really large and very popular that allow you to work with the web.</p>
	<ul>
		<li>Ruby
			<ul>
				<li>On Rails</li>
				<li>Sinatra</li>
			</ul>
		</li>
		<li>Python
			<ul>
				<li>Django</li>
				<li>Twisted</li>
			</ul>
		</li>
		<li>C#
			<ul>
				<li>ASP.NET</li>
				<li>MonoRail</li>
			</ul>
		</li>
		<li>JavaScript
			<ul>
				<li>Node.js</li>
				<li>Other frameworks based on Node.js(Express, Meteor)</li>
			</ul>
		</li>
</slide>
<comments></comments>

<title>Node.js is Javascript on the server</title>
<slide>	
	<p>Node is a web framework that is very minimal. It provides an API to send data and run a server process in JavaScript. After that, much of it is up to you.</p>
</slide>
<comments></comments>

<title>Node.js is programming your own server!</title>
<slide>	
	<p>Many more mature languages (like Ruby, or C#) hide a lot of what is going on. Node doesn't hide much from you.</p>
</slide>
<comments></comments>

<title>Hello World</title>
<slide>	
	<p>An example of a node.js server!</p>
	<code>
		var http = require('http');

		http.createServer(function(request, response){
		response.writeHead(200,{'Content-Type':'text/plain'});
		response.end('Hello World\n');}).listen(8124);

		console.log('Server running at http://127.0.0.1:8124/');
	</code>
</slide>
<comments></comments>

<title>Dissecting Hello World</title>
<slide>	
	<p>Let's break it down.</p>
	<code>
		var http = require('http'); //A Module

		//using http's method to create something that listens on port 8124
		http.createServer(function(request, response) { 
			//Inside a callback, we write the request header
			response.writeHead(200,{'Content-Type':'text/plain'});
			//we then end the response, while 
			response.end('Hello World\n');
		}).listen(8124);

		//Our old friend, console.log
		console.log('Server running at http://127.0.0.1:8124/');
	</code>
</slide>
<comments></comments>

<title>Ports</title>
<slide>	
	<p>Ports are like sub-addresses on your computer, or a server. A socket is a combination of an IP address and a Port.</p>
	<p>In the previous example, 8124 was the port we were using, on 127.0.0.1.</p>
	<p>Servers "listen" on ports - they tell the OS that if information comes in on that Port, they will handle it.</p>
	<p>80 is the default HTTP port. A further list of ports can be found <a src="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers">here</a></p>
</slide>
<comments>http://ortizonline.com/publications/tcpipsuitetutorial.htm</comments>

<title>Requests</title>
<slide>	
	<p>A request is composed of two parts. A Header and a Body. It is sent to the server, and explains what the client is requesting, and how it wants a response.</p>
	<code>
		GET /index.html HTTP/1.1
 		Host: www.example.com


	</code>
	<p>The last two lines are blank on purpose. The server has to send two blank lines (/r/n /r/n) in order to signal that the request has completed.</p> 
</slide>
<comments>explain /r/n and that there can be more HTTP headers than just the path.</comments>

<title>Request Headers</title>
<slide>	
	<p>The request head defines several things:</p>
	<ul>
		<li>The HTTP protocol spec</li>
		<li>The path requested - often this is a file path, but it can just indicate an action.</li>
		<li>The "Verb" - what you're trying to do. (HTTP1.0: GET, POST, HEAD)(HTTP1.1: OPTIONS,PUT,DELETE,TRACE,CONNECT)</li>
		<li>The Host - where you're asking information from.</li>
		<li>What kind of content types you'll accept</li>
		<li>A full list <a href="https://en.wikipedia.org/wiki/List_of_HTTP_header_fields">here</a></li>
	</ul>

</slide>
<comments>HEAD just asks for the headers, without the body.</comments>

<title>Request Body</title>
<slide>	
	<p>Sometimes, you'll have a request body. This is used to send data, like the contents of a form or some authorization data. It is sent with POST.</p>

</slide>
<comments></comments>

<title>GET vs POST</title>
<slide>	
	<p>GET is an HTTP Verb that we use to request information. We may optionally pass a "QueryString" with our GET request (or with post requests) in order to send data that we're OK with the user potentially modifying.</p>
	<p>POST is another Verb that we use in order to send a response body with - usually data from a form. The user can't directly modify this data but as you've seen, you can modify the page, so you can get any kind of data from a post. Because the data isn't URL encoded, it is usually easier.</p>
</slide>
<comments></comments>

<title>Routes</title>
<slide>	
	<p>In node, the "path" is sent along with the request. This path helps us know what the user was trying to access.</p>
	<p>A server can "listen" on a path, but it is better to parse the URL and then respond.</p>
	<code>
		http.createServer
	</code>
</slide>
<comments></comments>

<title>Responses</title>
<slide>	

</slide>
<comments></comments>

<title>Excercise Time!</title>
<slide>	

</slide>
<comments>Set up several routes, interpret a request. Bonus, log each time a user comes to the page</comments>